# my_aes128_ip_coprocessor
This AES implementation is an asynchronous, combinational implementation in Verilog; the module implements the encryption algorithm and the key expansion algorithm; the ciphertext result is generated after the propagation delay through the AES rounds; the AES coprocessor was tested with the NIST example found in AES_NIST.FIPS.197.pdf
The references for this implementation are:
[1] NIST, AES_NIST.FIPS.197, November 2001; posted in the Appendix. 
[2] M. Mayhew, ASIC Implementation of an AES co-processor, MASc Thesis, 2009, University of Guelph (pp. 46 – 67; posted on ENGG*4560 CourseLink.  
[3] J. Wolkerstorfer, E. Oswald, M. Lamberger (2002). An ASIC Implementation of the AES SBoxes. In: Preneel, B. (eds) Topics in Cryptology — CT-RSA 2002. CT-RSA 2002. Lecture Notes in Computer Science, vol 2271. Springer, Berlin, Heidelberg. https://doi-org.subzero.lib.uoguelph.ca/10.1007/3-540-45760-7_6; posted in the Appendix.
[4] Hua Li and Z. Friggstad, "An efficient architecture for the AES mix columns operation," 2005 IEEE International Symposium on Circuits and Systems (ISCAS), 2005, pp. 4637-4640 Vol. 5, doi: 10.1109/ISCAS.2005.1465666; posted in the Appendix. 
[5] L. R. Knudsen, M. J. B. Robshaw, The Block Cipher Companion, Springer, 2011.
This SoC design implements in Verilog the 128-bits AES encryption algorithm along with the 128-bits cipher key expansion targeting the DE1-SoC development board that we utilize for our ENGG*4560 laboratory. The implementation followed the AES-128 encryption algorithm described in [1] and was verified for all rounds using the numerical examples in [1]. The Verilog implementation of the AES is an asynchronous type implementation, entirely combinational circuitry; no clock is used within the AES module. As the inputs (plaintext and the secret key) to the AES module are changed, the encryption result will be generated to the ciphertext output after the propagation delay through the combinational gates from the start round to the final round.
Integrating the my_aes_128_ip Coprocessor Design into the Project
The AES 128-bit coprocessor was designed as a custom APB IP using the Platform Designer software tool. The my_aes_128_ip module is interfaced to the SoC HPS processor using the APB interface protocol. Your ENGG*4560 project needs to fully implement the hardware interface to the my_aes_128_ip module following the laboratory project application requirements. Follow the ENGG*4560 Laboratory Manual and ENGG*4560 Laboratory Project Tutorial: Design of Custom APB IP with the Platform Designer. The provided AES module is the main coprocessor module; however, you are responsible for implementing the hardware interface to this module in order to accomplish the project requirements. As a further note, you can use any AES module that you can find on GitHub, or you could implement your own AES module following the AES algorithm and my AES implementation example. 
Working on the ENGG*4560 project, it is important for the students to take time and understand the functionality of the AES algorithm and its hardware implementation. Therefore, I will present only the working Verilog code for my AES coprocessor implementation in the Appendix of this tutorial.
The hardware interface contains five main modules that are instantiated as building components. These are:
1.	write_mem_inp_aes: this is a memory block module that contains 8x32-bit memory locations that are memory-mapped and are used to write the input data to the AES coprocessor, specifically, the control word, the 128-bit plaintext, and the 128-bit key.
2.	write_mem_out_aes: this is a memory block module that contains 8x32-bit memory locations that are memory-mapped and are used to write the outputs from the AES coprocessor, specifically, the status word and the 128-bit ciphertext.
3.	control_hw: this is the main control module of the hardware interface. I have a set of simple instructions that I designed for controlling the AES coprocessor. These instructions are: IDLE, PTEXT_ld, KEY_ld, start_encryption, CTEXT_read; Note that more instructions can be added as required for the interface functionality. These instructions are the ones that I used to perform simple 128-bit AES encryptions. For my case, I implemented the control module as a simple decoder generating the required signals.
4.	aes128: this is the main AES-128 encryption module that performs asynchronous encryptions. When I say that the module performs asynchronous encryptions, it means that the module is designed entirely as a combinational circuitry. The inputs to the module are the 128-bit plaintext and the 128-bit key. Whenever the inputs are changed, the 128-bit ciphertext is generated at the module's output after the signal propagation delay through all the encryption rounds. The module develops the round keys and performs all the AES rounds in a chaining manner as described in the next AES Coprocessor Section.
5.	read_mem: this module reads the memory-mapped locations that are written by the write_mem_inp_aes and write_mem_out_aes modules. The inputs to this module are the memory output from the write modules as seen in the second figure.
AES Coprocessor Hardware Interface Architecture
This section will briefly describe the functionality of my AES-128 encryption Verilog module. To understand the implementation, please follow the course material for the AES encryption algorithm plus references [1] to [5].
The AES-128 coprocessor Verilog code is presented in the Appendix my_aes128_coprocessor.v of this tutorial. This section will explain the AES implementation by referring to the code lines in the Appendix. The code presents the APB hardware interface to the AES-128 coprocessor designed as a custom IP module (follow the ENGG4560 Laboratory Tutorial Design of Custom APB IP with the Platform Designer). However, you will need to fully implement the hardware interface to your coprocessor using the memory mapping technique. In addition, your hardware interface must support the project requirements and interface to the AES-128 coprocessor. For example, for the AES-128 encryption coprocessor, you could use the code presented in this tutorial, implement your version, or utilize a different implementation from online resources.
The subsequent three figures present the hardware architecture of my AES-128 coprocessor design. The hardware architecture follows the Cipher pseudocode from Figure 5 and the Key Expansion pseudocode from Figure 11 found in reference [1].
My AES-128 Verilog code can be viewed as two distinct sections: 
Section 1: my_aes128_coprocessor (…) main module (code lines 47 to 365). This module can be divided further into four independent subsections, as shown below:
1.	Input state data organization (code lines 48 – 85).
2.	The Key Expansion algorithm section (code lines 90 – 180). The Key Expansion section follows the pseudocode from Figure 11 of reference [1] and Fig. 3.1 diagram of reference [5].
3.	AES-128 cipher algorithm section (code lines 181 – 346). The cipher algorithm follows the pseudocode rounds algorithm (whitening round, rounds 1 to 9, and final round 10) presented in Figure 5 [1]. The rounds are implemented using the required state transformations as independent components (See Figure 5 algorithm [1]). As a note, you can optimize the code by using "for loop." However, you must ensure that your "for loop" is synthesizable.
4.	Ciphertext result generation section (code lines 348 to 365).
Section 2: Cipher transformations modules that form the fundamental transformations for the AES-128 cipher algorithm. These modules form the essential components of the cipher rounds. In this section, I implemented seven modules used by the cipher algorithm and one module used by the key expansion algorithm. 
1.	AddRoundKey (…) module (code lines 369 to 439): this module implements the AddRoundKey () transformation as described in Section 5.1.4 of reference [1]. The module simply implements bitwise xor operations between the round key and the state.
2.	subbytes8 (…) module (code lines 442 to 535): this module implements the S-Box operation on an 8-bit input using the arithmetic operations in the finite field GF(28). The S-Box operation is implemented using combinational logic equations. In this implementation, the operations of the AES-128 cipher in GF(28) field are viewed as an extension of the GF(24) field. The S-Box transformation for an 8-bit input was implemented following Fig. 2 architecture and the logic equations presented in reference [3].
3.	subbytes32 (…) module (code lines 537 to 590): this module implements the SubBytes () transformation of the state as described in Section 5.1.1 of reference [1], using the basic subbytes8 (…) module as components.
4.	shiftrows (…) module (code lines 592 to 633): this module implements the ShiftRows () transformation as described in Section 5.1.2 of reference [1]. The module performs simple wire connections from the input state to the output state.
5.	mixcolums1 (…) module (code lines 635 to 691):  this module implements the MixColums () transformation for one column of the state as presented in Section 5.1.3 of reference [1]. The module uses a combinational logic implementation diagram following Fig. 4 and the method illustrated in reference [4]. The entire column transformation is implemented using buffer and xor gates (see module code lines).
6.	mixcolums4 (…) module (code lines 693 to 736): this module implements the MixColums () operations for the 4-columns of the state.
7.	Keyschedule1 (…) module (code lines 738 to 775): this module implements the general logical equations as applied to an individual Key Expansion round (See Section 5.2 in reference [1]). This module is the primary component for generating the round keys in Section 1 of the code.
8.	Round_i (…) module (code lines 777 to 858): this module implements the general round operations of the AES cipher by instantiating the round transformations in order: subbytes32 (), shiftrows (), mixcolums4 (), and AddRoundKey (). This module is instantiated as a component for rounds 1 to 9 in Section 1 of the code. The whitening round (round 0) and round 10 of the AES-128 cipher are implemented by instantiating the components implementing their required operations.  
Final Note: You can optimize this code or use it as presented in the Appendix of this tutorial. The code has a large propagation delay due to its chaining rounds implementation style. Synthesizing the code, you will get a warning regarding this large propagation delay. However, the overall propagation delay is not a problem for generating the ciphertext result. I had no issues reading the correct ciphertext in my hardware interface implementation since the HPS processor issues the coprocessor encryption instructions through the C code software driver, and there are many clock cycles between these instructions being sent to the coprocessor. 
